<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('header') %>
  <!-- Eigene Styles -->
  <link href="<%= contextPath %>/css/style.css" rel="stylesheet" />
  <!-- SurveyJS Scripts -->
  <link rel="stylesheet" href="<%= contextPath %><%= locale %>/vendor/survey-core/survey-core.min.css" />
  <script src="<%= contextPath %><%= locale %>/vendor/survey-core/survey.core.min.js"></script>
  <script src="<%= contextPath %><%= locale %>/vendor/survey-js-ui/survey-js-ui.min.js"></script>
  <script src="<%= contextPath %><%= locale %>/vendor/survey-core/survey.i18n.min.js"></script>
</head>
<body>
  <%- include('nav', navigation) %>
  <div id="surveyContainer"></div>
  
  <script>
    // Hilfsfunktion für mehrsprachige Nachrichten
    function getLocalizedMessage(key, locale) {
      const messages = {
        incompleteWarning: {
          en: "Please answer either all questions or none – partial completion is not allowed for final submission.",
          de: "Bitte beantworten Sie entweder alle Fragen oder keine – teilweises Ausfüllen ist für die finale Abgabe nicht erlaubt.",
          ja: "最終送信では、すべての質問に回答するか、何も回答しないでください。"
        },
        requiredError: {
          en: "Please answer this question.",
          de: "Bitte beantworten Sie diese Frage.",
          ja: "この質問に回答してください。"
        },
        submitError: {
          en: "Error submitting survey. Please try again.",
          de: "Fehler beim Senden der Umfrage. Bitte versuchen Sie es erneut.",
          ja: "アンケートの送信でエラーが発生しました。もう一度お試しください。"
        }
      };
      return messages[key][locale] || messages[key]['en'];
    }

    // 1) Survey initialisieren
    const surveyModel = new Survey.Model(<%- JSON.stringify(survey) %>);
    const currentLocale = <%- JSON.stringify(locale) %>;
    surveyModel.locale = currentLocale;

    // 2) Theme Settings
    surveyModel.applyTheme({
      themeName: "default",
      colorPalette: "light",
      isPanelless: false,
      cssVariables: {
        "--sv-color-primary": "#50b034",
        "--sv-color-primary-light": "#7bc95f",
        "--sv-color-primary-dark": "#3a8527"
      }
    });

    // 3) One-time alerts for missing answers (simple, page-scoped)
    const shownPageWarnings = new Set();
    let shownCompleteWarning = false;

    // Localized warning copy
    const WARNING_TEXTS = {
      page: {
        en: 'Some questions on this page are unanswered. You can leave them blank, but we recommend completing all fields.\n\nClick Next again to continue.',
        de: 'Einige Fragen auf dieser Seite sind unbeantwortet. Sie können diese leer lassen, wir empfehlen jedoch, alle Felder auszufüllen.\n\nKlicken Sie erneut auf Weiter, um fortzufahren.',
        ja: 'このページには未回答の質問があります。空欄のままでも構いませんが、すべての項目の回答を推奨します。\n\n続行するにはもう一度［次へ］をクリックしてください。'
      },
      complete: {
        en: 'Some survey questions are unanswered. You can submit anyway, but we recommend completing all fields.\n\nClick Submit again to finish.',
        de: 'Einige Fragen der Umfrage sind unbeantwortet. Sie können trotzdem abschließen, wir empfehlen jedoch, alle Felder auszufüllen.\n\nKlicken Sie erneut auf Absenden, um zu beenden.',
        ja: '未回答の質問があります。送信は可能ですが、すべての項目の回答を推奨します。\n\n完了するにはもう一度［送信］をクリックしてください。'
      }
    };

    function tWarning(type) {
      const group = WARNING_TEXTS[type] || {};
      return group[currentLocale] || group.en || '';
    }

    // Treat a question as missing if it's visible, has a name and no value
    function isAnswerMissing(sender, question) {
      if (!question || typeof question.getType !== 'function') return false;
      const t = question.getType();
      // Ignore non-input/static content
      if (t === 'html' || t === 'expression' || t === 'image') return false;
      if (!question.name || !question.isVisible) return false;
      const value = sender.getValue(question.name);
      return Array.isArray(value) ? value.length === 0 : (value === undefined || value === null || value === '');
    }

    function countMissingOnPage(sender, page) {
      if (!page || !Array.isArray(page.questions)) return 0;
      return page.questions.reduce((acc, q) => acc + (isAnswerMissing(sender, q) ? 1 : 0), 0);
    }

    function countMissingOverall(sender) {
      return sender.getAllQuestions().reduce((acc, q) => acc + (isAnswerMissing(sender, q) ? 1 : 0), 0);
    }

    // Do NOT make questions required so navigation remains possible
    surveyModel.onAfterRenderQuestion.add((sender, options) => {
      const q = options.question;
      if (q && typeof q.getType === 'function' && q.getType() === 'rating') {
        q.isRequired = false;
      }
    });

    // Warn once per page if there are missing answers on navigation
    surveyModel.onCurrentPageChanging.add((sender, options) => {
      const page = options.oldCurrentPage;
      if (!page) { options.allowChanging = true; return; }

      const pageKey = page.name || String(sender.pages.indexOf(page));
      const missing = countMissingOnPage(sender, page);

      if (missing > 0 && !shownPageWarnings.has(pageKey)) {
        // One-time warning for this page, block current navigation
        alert(tWarning('page'));
        shownPageWarnings.add(pageKey);
        options.allowChanging = false;
        return;
      }

      // After first warning, allow navigation even if incomplete
      options.allowChanging = true;
    });

    // Warn once on final submit if there are missing answers
    surveyModel.onCompleting.add((sender, options) => {
      const missing = countMissingOverall(sender);
      if (missing > 0 && !shownCompleteWarning) {
        alert(tWarning('complete'));
        shownCompleteWarning = true;
        options.allowComplete = false; // Block only the first submit attempt
        return;
      }
      options.allowComplete = true; // Allow submit afterwards
    });

    // Build a complete answers object: unanswered -> -1
    function buildCompleteAnswers(model) {
      const result = {};
      const questions = model.getAllQuestions();
      for (const q of questions) {
        if (!q || !q.name) continue;
        // Consider only visible questions for completion purposes
        if (typeof q.isVisible === 'boolean' && !q.isVisible) continue;
        const val = model.getValue(q.name);
        const isEmptyArray = Array.isArray(val) && val.length === 0;
        const isEmptyObject = val && typeof val === 'object' && !Array.isArray(val) && Object.keys(val).length === 0;
        const isEmptyScalar = val === undefined || val === null || val === '';
        result[q.name] = (isEmptyScalar || isEmptyArray || isEmptyObject) ? -1 : val;
      }
      return result;
    }

    // 5) Submit Handler mit verbesserter Fehlerbehandlung
    surveyModel.onComplete.add(function (sender) {
      const ctx = "<%= contextPath %>";
      const id = "<%= survey.id %>";
      const lang = "<%= locale %>";
      const url = `${ctx === '/' ? '' : ctx}/${lang}/survey/${id}/complete`;

      // Loading-State anzeigen (optional)
      sender.showLoadingIndicator = true;
      const completeAnswers = buildCompleteAnswers(sender);

      fetch(url, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          data: completeAnswers,
          completedAt: new Date().toISOString(),
          surveyId: id
        })
      })
      .then(async res => {
        sender.showLoadingIndicator = false;
        
        if (res.ok) {
          // Prüfen ob Response JSON ist
          const contentType = res.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            const result = await res.json();
            if (result.redirectUrl) {
              window.location.href = result.redirectUrl;
            } else {
              // Fallback zur ursprünglichen Methode
              window.location.href = res.url;
            }
          } else {
            window.location.href = res.url || `${ctx === '/' ? '' : ctx}/${lang}/survey/complete`;
          }
        } else {
          try {
            const errorData = await res.json();
            console.error('Survey submission failed:', errorData);
          } catch (e) {
            console.error('Survey submission failed with status:', res.status);
          }
          alert(getLocalizedMessage('submitError', currentLocale));
        }
      })
      .catch(error => {
        sender.showLoadingIndicator = false;
        console.error('Network error:', error);
        alert(getLocalizedMessage('submitError', currentLocale));
      });
    });

    // 6) Survey rendern wenn DOM bereit ist
    document.addEventListener("DOMContentLoaded", () => {
      const container = document.getElementById("surveyContainer");
      if (container) {
        surveyModel.render(container);
      } else {
        console.error('Survey container not found');
      }
    });
  </script>
  
  <%- include('footer') %>
</body>
</html>
